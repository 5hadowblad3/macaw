{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE TypeApplications #-}

module Data.Macaw.PPC.Semantics.TH
  ( genExecInstruction
  , FromCrucibleBaseType
  , addExpr
  ) where

import qualified Data.ByteString as BS
import qualified Data.Constraint as C

import           Control.Lens ( (.=) )
import           Data.Proxy ( Proxy(..) )
import qualified Data.List as L
import qualified Data.Text as T
import           Language.Haskell.TH
import           Language.Haskell.TH.Syntax
import           GHC.TypeLits
import           Text.Read ( readMaybe )

import           Data.Parameterized.Classes
import           Data.Parameterized.FreeParamF ( FreeParamF(..) )
import qualified Data.Parameterized.Lift as LF
import qualified Data.Parameterized.Map as Map
import qualified Data.Parameterized.NatRepr as NR
import qualified Data.Parameterized.Nonce as PN
import qualified Data.Parameterized.ShapedList as SL
import           Data.Parameterized.Some ( Some(..) )
import qualified Data.Parameterized.TraversableFC as FC
import           Data.Parameterized.Witness ( Witness(..) )
import qualified Lang.Crucible.Solver.Interface as SI
import qualified Lang.Crucible.Solver.SimpleBuilder as S
import qualified Lang.Crucible.Solver.SimpleBackend as S
import qualified Lang.Crucible.Solver.Symbol as Sy
import qualified Lang.Crucible.BaseTypes as S

import qualified Dismantle.PPC as D
import qualified Dismantle.Tablegen.TH.Capture as DT

import qualified SemMC.BoundVar as BV
import           SemMC.Formula
import qualified SemMC.Architecture as A
import qualified SemMC.Architecture.Location as L
import qualified SemMC.Architecture.PPC.Eval as PE
import qualified SemMC.Architecture.PPC.Location as APPC
import qualified Data.Macaw.CFG as M
import qualified Data.Macaw.CFG.Block as M
import qualified Data.Macaw.Memory as M
import qualified Data.Macaw.Types as M

import Data.Parameterized.NatRepr ( knownNat
                                  , addNat
                                  , natValue
                                  )

import           Data.Macaw.PPC.Arch
import           Data.Macaw.PPC.Generator
import           Data.Macaw.PPC.Operand
import           Data.Macaw.PPC.PPCReg

type Sym t = S.SimpleBackend t

type family FromCrucibleBaseType (btp :: S.BaseType) :: M.Type where
  FromCrucibleBaseType (S.BaseBVType w) = M.BVType w
  FromCrucibleBaseType (S.BaseBoolType) = M.BoolType

-- run stack with --ghc-options=-ddump-splices

-- | A different parameterized pair wrapper; the one in Data.Parameterized.Map
-- hides the @tp@ parameter under an existential, while we need the variant that
-- exposes it.
data PairF a b tp = PairF (a tp) (b tp)

-- | Generate the top-level lambda with a case expression over an instruction
-- (casing on opcode)
--
-- > \ipVar (Instruction opcode operandList) ->
-- >   case opcode of
-- >     ${CASES}
--
-- where each case in ${CASES} is defined by 'mkSemanticsCase'; each case
-- matches one opcode.
instructionMatcher :: (OrdF a, LF.LiftF a,
                       A.Architecture arch,
                       L.Location arch ~ APPC.Location arch,
                       1 <= APPC.ArchRegWidth arch,
                       M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                   => Map.MapF (Witness c a) (PairF (ParameterizedFormula (Sym t) arch) (DT.CaptureInfo c a))
                   -> Q Exp
instructionMatcher formulas = do
  ipVarName <- newName "ipVal"
  opcodeVar <- newName "opcode"
  operandListVar <- newName "operands"
  let normalCases = map (mkSemanticsCase ipVarName operandListVar) (Map.toList formulas)
  lamE [varP ipVarName, conP 'D.Instruction [varP opcodeVar, varP operandListVar]] (caseE (varE opcodeVar) (normalCases ++ specialSemanticsCases))

-- | Manually-provided semantics for instructions whose full semantics cannot be
-- expressed in our semantics format.
--
-- This includes instructions with special side effects that we don't have a way
-- to talk about in the semantics; especially useful for architecture-specific
-- terminator statements.
specialSemanticsCases :: [MatchQ]
specialSemanticsCases =
  [ match (conP 'D.SC []) (normalB syscallBody) []
  , match (conP 'D.TRAP []) (normalB trapBody) []
  ]
  where
    syscallBody = [| Just (finishWithTerminator (M.ArchTermStmt PPCSyscall)) |]
    trapBody = [| Just (finishWithTerminator (M.ArchTermStmt PPCTrap)) |]

-- | Generate a single case for one opcode of the case expression.
--
-- > ADD4 -> ${BODY}
--
-- where the ${BODY} is generated by 'mkOperandListCase'
mkSemanticsCase :: (LF.LiftF a,
                    A.Architecture arch,
                    L.Location arch ~ APPC.Location arch,
                    1 <= APPC.ArchRegWidth arch,
                    M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                => Name
                -> Name
                -> Map.Pair (Witness c a) (PairF (ParameterizedFormula (Sym t) arch) (DT.CaptureInfo c a))
                -> MatchQ
mkSemanticsCase ipVarName operandListVar (Map.Pair (Witness opc) (PairF semantics capInfo)) =
  match (conP (DT.capturedOpcodeName capInfo) []) (normalB (mkOperandListCase ipVarName operandListVar opc semantics capInfo)) []

-- | For each opcode case, we have a sub-case expression to destructure the
-- operand list into names that we can reference.  This generates an expression
-- of the form:
--
-- > case operandList of
-- >   op1 :> op2 :> op3 :> Nil -> ${BODY}
--
-- where ${BODY} is generated by 'genCaseBody', which references the operand
-- names introduced by this case (e.g., op1, op2, op3).  Those names are pulled
-- from the DT.CaptureInfo, and have been pre-allocated.  See
-- Dismantle.Tablegen.TH.Capture.captureInfo for information on how those names
-- are generated.
--
-- Note that the structure of the operand list is actually a little more
-- complicated than the above.  Each operand actually has an additional level of
-- wrapper around it, and really looks like:
--
-- >    Dismantle.PPC.ADD4
-- >      -> case operands_ayaa of {
-- >           (Gprc gprc0 :> (Gprc gprc1 :> (Gprc gprc2 :> Nil)))
-- >             -> ${BODY}
--
-- in an example with three general purpose register operands.
mkOperandListCase :: (L.Location arch ~ APPC.Location arch,
                      A.Architecture arch,
                      1 <= APPC.ArchRegWidth arch,
                      M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                  => Name
                  -> Name
                  -> a tp
                  -> ParameterizedFormula (Sym t) arch tp
                  -> DT.CaptureInfo c a tp
                  -> Q Exp
mkOperandListCase ipVarName operandListVar opc semantics capInfo = do
  body <- genCaseBody ipVarName opc semantics (DT.capturedOperandNames capInfo)
  DT.genCase capInfo operandListVar body

data BoundVarInterpretations arch t =
  BoundVarInterpretations { locVars :: Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
                          , opVars  :: Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
                          }

-- | This is the function that translates formulas (semantics) into expressions
-- that construct macaw terms.
--
-- The stub implementation is essentially
--
-- > undefined ipVar arg1 arg2
--
-- to avoid unused variable warnings.
--
-- The two maps (locVars and opVars) are crucial for translating parameterized
-- formulas into expressions.
genCaseBody :: forall a sh t arch
               . (L.Location arch ~ APPC.Location arch,
                  A.Architecture arch,
                  1 <= APPC.ArchRegWidth arch,
                  M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
            => Name
            -> a sh
            -> ParameterizedFormula (Sym t) arch sh
            -> SL.ShapedList (FreeParamF Name) sh
            -> Q Exp
genCaseBody ipVarName _opc semantics varNames =
  translateFormula ipVarName semantics (BoundVarInterpretations locVarsMap opVarsMap) varNames
  where
    locVarsMap :: Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
    locVarsMap = Map.foldrWithKey (collectVarForLocation (Proxy @arch)) Map.empty (pfLiteralVars semantics)

    opVarsMap :: Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
    opVarsMap = SL.foldrFCIndexed (collectOperandVars varNames) Map.empty (pfOperandVars semantics)

collectVarForLocation :: forall tp arch proxy t
                       . proxy arch
                      -> L.Location arch tp
                      -> SI.BoundVar (Sym t) tp
                      -> Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
                      -> Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
collectVarForLocation _ loc bv = Map.insert bv loc

-- | Index variables that map to operands
--
-- We record the TH 'Name' for the 'SI.BoundVar' that stands in for each
-- operand.  The idea will be that we will look up bound variables in this map
-- to be able to compute a TH expression to refer to it.
--
-- We have to unwrap and rewrap the 'FreeParamF' because the type parameter
-- changes when we switch from 'BV.BoundVar' to 'SI.BoundVar'.  See the
-- SemMC.BoundVar module for information about the nature of that change
-- (basically, from 'Symbol' to BaseType).
collectOperandVars :: forall sh tp arch t
                    . SL.ShapedList (FreeParamF Name) sh
                   -> SL.Index sh tp
                   -> BV.BoundVar (Sym t) arch tp
                   -> Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
                   -> Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
collectOperandVars varNames ix (BV.BoundVar bv) m =
  case SL.indexShapedList varNames ix of
    FreeParamF name -> Map.insert bv (FreeParamF name) m

-- | Generate an implementation of 'execInstruction' that runs in the
-- 'PPCGenerator' monad.  We pass in both the original list of semantics files
-- along with the list of opcode info objects.  We can match them up using
-- equality on opcodes (via a MapF).  Generating a combined list up-front would
-- be ideal, but is difficult for various TH reasons (we can't call 'lift' on
-- all of the things we would need to for that).
--
-- The structure of the term produced is documented in 'instructionMatcher'
genExecInstruction :: (A.Architecture arch,
                       OrdF a,
                       ShowF a,
                       LF.LiftF a,
                       L.Location arch ~ APPC.Location arch,
                       1 <= APPC.ArchRegWidth arch,
                       M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                   => proxy arch
                   -> (forall sh . c sh C.:- BuildOperandList arch sh)
                   -- ^ A constraint implication to let us extract/weaken the
                   -- constraint in our 'Witness' to the required 'BuildOperandList'
                   -> [(Some (Witness c a), BS.ByteString)]
                   -- ^ A list of opcodes (with constraint information
                   -- witnessed) paired with the bytestrings containing their
                   -- semantics.  This comes from semmc.
                   -> [Some (DT.CaptureInfo c a)]
                   -- ^ Extra information for each opcode to let us generate
                   -- some TH to match them.  This comes from the semantics
                   -- definitions in semmc.
                   -> Q Exp
genExecInstruction _ impl semantics captureInfo = do
  Some ng <- runIO PN.newIONonceGenerator
  sym <- runIO (S.newSimpleBackend ng)
  formulas <- runIO (loadFormulas sym impl semantics)
  let formulasWithInfo = foldr (attachInfo formulas) Map.empty captureInfo
  instructionMatcher formulasWithInfo
  where
    attachInfo m0 (Some ci) m =
      let co = DT.capturedOpcode ci
      in case Map.lookup co m0 of
        Nothing -> m
        Just pf -> Map.insert co (PairF pf ci) m

-- SemMC.Formula: instantiateFormula

-- Add an expression in the PPCGenerator monad. This returns a Macaw value
-- corresponding to the added expression.
addExpr :: M.ArchConstraints ppc => Expr ppc ids tp -> PPCGenerator ppc ids (M.Value ppc ids tp)
addExpr expr = do
  case expr of
    ValueExpr val -> return val
    AppExpr app -> do
      assignment <- addAssignment (M.EvalApp app)
      return $ M.AssignedValue assignment

natReprTH :: M.NatRepr w -> Q Exp
natReprTH w = [| knownNat :: M.NatRepr $(litT (numTyLit (natValue w))) |]

natReprFromIntTH :: Int -> Q Exp
natReprFromIntTH i = [| knownNat :: M.NatRepr $(litT (numTyLit (fromIntegral i))) |]

-- | Sequence a list of monadic actions without constructing an intermediate
-- list structure
doSequenceQ :: [ExpQ] -> Q Exp
doSequenceQ = doE . map noBindS

translateFormula :: forall arch t sh .
                    (L.Location arch ~ APPC.Location arch,
                     A.Architecture arch,
                     1 <= APPC.ArchRegWidth arch,
                     M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                 => Name
                 -> ParameterizedFormula (Sym t) arch sh
                 -> BoundVarInterpretations arch t
                 -> SL.ShapedList (FreeParamF Name) sh
                 -> Q Exp
translateFormula ipVarName semantics interps varNames = do
  let exps = map translateDefinition (Map.toList (pfDefs semantics))
  [| Just $(doSequenceQ exps) |]
  where translateDefinition :: Map.Pair (Parameter arch sh) (S.SymExpr (Sym t))
                            -> Q Exp
        translateDefinition (Map.Pair param expr) = do
          case param of
            OperandParameter _w idx -> do
              let FreeParamF name = varNames `SL.indexShapedList` idx
              [| do val <- $(addEltTH interps expr)
                    let reg = toPPCReg $(varE name)
                    curPPCState . M.boundValue reg .= val
               |]
            LiteralParameter APPC.LocMem -> writeMemTH interps expr
            LiteralParameter loc -> do
              [| do val <- $(addEltTH interps expr)
                    curPPCState . M.boundValue $(locToRegTH (Proxy @arch) loc) .= val
               |]
            FunctionParameter str (WrappedOperand _ opIx) _w -> do
              let FreeParamF boundOperandName = SL.indexShapedList varNames opIx
              case lookup str (A.locationFuncInterpretation (Proxy @arch)) of
                Nothing -> [| error ("Function has no definition: " ++ show $(lift str)) |]
                Just fi -> do
                  [| do case $(varE (A.exprInterpName fi)) $(varE boundOperandName) of
                          Just reg -> do
                            val <- $(addEltTH interps expr)
                            curPPCState . M.boundValue (toPPCReg reg) .= val
                          Nothing -> error ("Invalid instruction form at " ++ show $(varE ipVarName))
                   |]

addEltTH :: forall arch t ctp .
            (L.Location arch ~ APPC.Location arch,
             A.Architecture arch,
             1 <= APPC.ArchRegWidth arch,
             M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
         => BoundVarInterpretations arch t
         -> S.Elt t ctp
         -> Q Exp
addEltTH interps elt = case elt of
  S.BVElt w val _loc ->
    [| return (M.BVValue $(natReprTH w) $(lift val)) |]
  S.AppElt appElt -> do
    [| do expr <- $(crucAppToExprTH (S.appEltApp appElt) interps)
          addExpr expr
     |]
  S.BoundVarElt bVar ->
    case Map.lookup bVar (locVars interps) of
      Just loc -> [| getRegValue $(locToRegTH (Proxy @arch) loc) |]
      Nothing  ->
        case Map.lookup bVar (opVars interps) of
          Just (FreeParamF name) -> [| extractValue $(varE name) |]
          Nothing -> fail $ "bound var not found: " ++ show bVar
  S.NonceAppElt n -> evalNonceAppTH interps (S.nonceEltApp n)
  S.SemiRingLiteral {} -> [| error "SemiRingLiteral Elts are not supported" |]

symFnName :: S.SimpleSymFn t args ret -> String
symFnName = T.unpack . Sy.solverSymbolAsText . S.symFnName

writeMemTH :: forall arch t tp
            . (L.Location arch ~ APPC.Location arch,
                A.Architecture arch,
                1 <= APPC.ArchRegWidth arch,
                M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
           => BoundVarInterpretations arch t
           -> S.Elt t tp
           -> Q Exp
writeMemTH bvi expr =
  case expr of
    S.NonceAppElt n ->
      case S.nonceEltApp n of
        S.FnApp symFn args
          | Just memWidth <- matchWriteMemWidth (symFnName symFn) ->
            case FC.toListFC Some args of
              [_, Some addr, Some val] ->
                [| do addrVal <- $(addEltTH bvi addr)
                      writtenVal <- $(addEltTH bvi val)
                      let memRepr = M.BVMemRepr $(natReprFromIntTH memWidth) M.BigEndian
                      addStmt (M.WriteMem addrVal memRepr writtenVal)
                 |]
              _ -> fail ("Invalid memory write expression: " ++ showF expr)
        _ -> fail ("Unexpected memory definition: " ++ showF expr)
    _ -> fail ("Unexpected memory definition: " ++ showF expr)

-- | Match a "write_mem" intrinsic and return the number of bytes written
matchWriteMemWidth :: String -> Maybe Int
matchWriteMemWidth s = do
  suffix <- L.stripPrefix "write_mem_" s
  (`div` 8) <$> readMaybe suffix

evalNonceAppTH :: forall arch t tp
                . (A.Architecture arch,
                   L.Location arch ~ APPC.Location arch,
                   1 <= APPC.ArchRegWidth arch,
                   M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
               => BoundVarInterpretations arch t
               -> S.NonceApp t (S.Elt t) tp
               -> Q Exp
evalNonceAppTH bvi nonceApp =
  case nonceApp of
    S.FnApp symFn args -> do
      let fnName = symFnName symFn
      -- Recursively evaluate the arguments.  In the recursive evaluator, we
      -- expect two cases:
      --
      -- 1) The argument is a name (via S.BoundVarElt); we want to return a
      -- simple TH expression that just refers to that name
      --
      -- 2) The argument is another call, which we want to evaluate into a
      -- simple TH expression
      --
      -- 3) Otherwise, we can probably just call the standard evaluator on it
      -- (this will probably be the case for read_mem and the floating point
      -- functions)
      --
      -- At the top level (after cases 1 and 2), we need to call 'extractValue' *once*.
      case fnName of
        "ppc_is_r0" -> do
          case FC.toListFC Some args of
            [Some operand] -> do
              -- The operand can be either a variable (TH name bound from
              -- matching on the instruction operand list) or a call on such.
              case operand of
                S.BoundVarElt bv -> do
                  case Map.lookup bv (opVars bvi) of
                    Just (FreeParamF name) -> [| extractValue (PE.interpIsR0 $(varE name)) |]
                    Nothing -> fail ("bound var not found: " ++ show bv)
                S.NonceAppElt nonceApp' -> do
                  case S.nonceEltApp nonceApp' of
                    S.FnApp symFn' args' -> do
                      let recName = symFnName symFn'
                      case lookup recName (A.locationFuncInterpretation (Proxy @arch)) of
                        Nothing -> fail ("Unsupported UF: " ++ recName)
                        Just fi -> do
                          case FC.toListFC (asName fnName bvi) args' of
                            [] -> fail ("zero-argument uninterpreted functions are not supported: " ++ fnName)
                            argNames -> do
                              let call = appE (varE (A.exprInterpName fi)) $ foldr1 appE (map varE argNames)
                              [| extractValue (PE.interpIsR0 ($(call))) |]
                    _ -> fail ("Unsupported nonce app type")
                _ -> fail "Unsupported operand to ppc.is_r0"
            _ -> fail ("Invalid argument list for ppc.is_r0: " ++ showF args)
        "test_bit_dynamic" ->
          case FC.toListFC Some args of
            [Some bitNum, Some loc] -> do
              [| do bitNumExp <- $(addEltTH bvi bitNum)
                    locExp <- $(addEltTH bvi loc)
                    addExpr (AppExpr (M.BVTestBit bitNumExp locExp))
               |]
            _ -> fail ("Unsupported argument list for test_bit_dynamic: " ++ showF args)
        _ | Just nBytes <- readMemBytes fnName -> do
            case FC.toListFC Some args of
              [_, Some addrElt] -> do
                -- read_mem has a shape such that we expect two arguments; the
                -- first is just a stand-in in the semantics to represent the
                -- memory.
                [| do let memRep = M.BVMemRepr (NR.knownNat :: NR.NatRepr $(litT (numTyLit (fromIntegral nBytes)))) M.BigEndian
                      addr <- $(addEltTH bvi addrElt)
                      assignment <- addAssignment (M.ReadMem addr memRep)
                      return (M.AssignedValue assignment)
                 |]
              _ -> fail ("Unexpected arguments to read_mem: " ++ showF args)
          | Just fpFunc <- elementaryFPName fnName -> floatingPointTH bvi fpFunc args
          | otherwise ->
            case lookup fnName (A.locationFuncInterpretation (Proxy @arch)) of
              Nothing -> [| error ("Unsupported UF: " ++ show $(litE (StringL fnName))) |]
              Just fi -> do
                -- args is an assignment that contains elts; we could just generate
                -- expressions that evaluate each one and then splat them into new names
                -- that we apply our name to.
                case FC.toListFC (asName fnName bvi) args of
                  [] -> fail ("zero-argument uninterpreted functions are not supported: " ++ fnName)
                  argNames -> do
                    let call = appE (varE (A.exprInterpName fi)) $ foldr1 appE (map varE argNames)
                    [| extractValue ($(call)) |]
    _ -> [| error "Unsupported NonceApp case" |]

elementaryFPName :: String -> Maybe String
elementaryFPName = L.stripPrefix "fp_"

floatingPointTH :: forall arch t f c
                 . (L.Location arch ~ APPC.Location arch,
                     A.Architecture arch,
                     1 <= APPC.ArchRegWidth arch,
                     M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch,
                     FC.FoldableFC f)
                 => BoundVarInterpretations arch t
                 -> String
                 -> f (S.Elt t) c
                 -> Q Exp
floatingPointTH bvi fnName args =
  case FC.toListFC Some args of
    [Some a] ->
      case fnName of
        "round_single" ->
          [| do fpval <- $(addEltTH bvi a)
                addExpr (AppExpr (M.FPCvt M.DoubleFloatRepr fpval M.SingleFloatRepr))
           |]
        "abs" ->
          -- Note that fabs is only defined for doubles; the operation is the
          -- same for single and double precision on PPC, so there is only a
          -- single instruction.
          [| do fpval <- $(addEltTH bvi a)
                addExpr (AppExpr (M.FPAbs M.DoubleFloatRepr fpval))
           |]
        "negate64" ->
          [| do fpval <- $(addEltTH bvi a)
                addExpr (AppExpr (M.FPNeg M.DoubleFloatRepr fpval))
           |]
        "negate32" ->
          [| do fpval <- $(addEltTH bvi a)
                addExpr (AppExpr (M.FPNeg M.SingleFloatRepr fpval))
           |]
        _ -> fail ("Unsupported unary floating point intrinsic: " ++ fnName)
    [Some a, Some b] ->
      case fnName of
        "add64" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPAdd M.DoubleFloatRepr valA valB))
           |]
        "add32" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPAdd M.SingleFloatRepr valA valB))
           |]
        "sub64" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPSub M.DoubleFloatRepr valA valB))
           |]
        "sub32" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPSub M.SingleFloatRepr valA valB))
           |]
        "mul64" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPMul M.DoubleFloatRepr valA valB))
           |]
        "mul32" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPMul M.SingleFloatRepr valA valB))
           |]
        "div64" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPDiv M.DoubleFloatRepr valA valB))
           |]
        "div32" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPDiv M.SingleFloatRepr valA valB))
           |]
        _ -> fail ("Unsupported binary floating point intrinsic: " ++ fnName)
    [Some a, Some b, Some c] ->
      case fnName of
        "muladd64" ->
          -- FIXME: This is very wrong - we need a separate constructor for it
          -- a * c + b
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                valC <- $(addEltTH bvi c)
                prodVal <- addExpr (AppExpr (M.FPMul M.DoubleFloatRepr valA valC))
                addExpr (AppExpr (M.FPAdd M.DoubleFloatRepr prodVal valB))
           |]
        "muladd32" ->
          -- a * c + b
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                valC <- $(addEltTH bvi c)
                prodVal <- addExpr (AppExpr (M.FPMul M.SingleFloatRepr valA valC))
                addExpr (AppExpr (M.FPAdd M.SingleFloatRepr prodVal valB))
           |]
        _ -> fail ("Unsupported ternary floating point intrinsic: " ++ fnName)
    _ -> fail ("Unsupported floating point intrinsic: " ++ fnName)

-- | Parse the name of a memory read intrinsic and return the number of bytes
-- that it reads.  For example
--
-- > readMemBytes "read_mem_8" == Just 1
readMemBytes :: String -> Maybe Int
readMemBytes s = do
  nBitsStr <- L.stripPrefix "read_mem_" s
  nBits <- readMaybe nBitsStr
  return (nBits `div` 8)

asName :: String -> BoundVarInterpretations arch t -> S.Elt t tp -> Name
asName ufName bvInterps elt =
  case elt of
    S.BoundVarElt bVar ->
      case Map.lookup bVar (opVars bvInterps) of
        Nothing -> error ("Expected " ++ show bVar ++ " to have an interpretation")
        Just (FreeParamF name) -> name
    _ -> error ("Unexpected elt as name (" ++ showF elt ++ ") in " ++ ufName)

-- Unimplemented:

-- Don't need to implement:
--   - all SemiRing operations (not using)
--   - all "Basic arithmetic operations" (not using)
--   - all "Operations that introduce irrational numbers" (not using)
--   - BVUnaryTerm (not using)
--   - all array operations (probably not using)
--   - all conversions
--   - all complex operations
--   - all structs

-- Might need to implement later:
--   - BVUdiv, BVUrem, BVSdiv, BVSrem
crucAppToExprTH :: (L.Location arch ~ APPC.Location arch,
                    A.Architecture arch,
                   1 <= APPC.ArchRegWidth arch,
                   M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                => S.App (S.Elt t) ctp
                -> BoundVarInterpretations arch t
                -> Q Exp
crucAppToExprTH elt interps = case elt of
  S.TrueBool  -> [| return $ ValueExpr (M.BoolValue True) |]
  S.FalseBool -> [| return $ ValueExpr (M.BoolValue False) |]
  S.NotBool bool ->
    [| do bval <- $(addEltTH interps bool)
          return (AppExpr (M.NotApp bval))
     |]
  S.AndBool bool1 bool2 ->
    [| do bval1 <- $(addEltTH interps bool1)
          bval2 <- $(addEltTH interps bool2)
          return (AppExpr (M.AndApp bval1 bval2))
     |]
  S.XorBool bool1 bool2 ->
    [| do bval1 <- $(addEltTH interps bool1)
          bval2 <- $(addEltTH interps bool2)
          return (AppExpr (M.XorApp bval1 bval2))
     |]
  S.IteBool test t f ->
    [| do testVal <- $(addEltTH interps test)
          tval <- $(addEltTH interps t)
          fval <- $(addEltTH interps f)
          return (AppExpr (M.Mux M.BoolTypeRepr testVal tval fval))
     |]
  S.BVIte w _ test t f ->
    [| do let rep = $(natReprTH w)
          testVal <- $(addEltTH interps test)
          tval <- $(addEltTH interps t)
          fval <- $(addEltTH interps f)
          return (AppExpr (M.Mux (M.BVTypeRepr rep) testVal tval fval))
     |]
  S.BVEq bv1 bv2 ->
    [| do bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.Eq bval1 bval2))
     |]
  S.BVSlt bv1 bv2 ->
    [| do bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVSignedLt bval1 bval2))
     |]
  S.BVUlt bv1 bv2 ->
    [| do bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVUnsignedLt bval1 bval2))
     |]
  S.BVConcat w bv1 bv2 -> do
    let u = S.bvWidth bv1
        v = S.bvWidth bv2
    [| do bv1Val <- $(addEltTH interps bv1)
          bv2Val <- $(addEltTH interps bv2)
          S.LeqProof <- return $ S.leqAdd2 (S.leqRefl $(natReprTH u)) (S.leqProof (knownNat @1) $(natReprTH v))
          pf1@S.LeqProof <- return $ S.leqAdd2 (S.leqRefl $(natReprTH v)) (S.leqProof (knownNat @1) $(natReprTH u))
          Refl <- return $ S.plusComm $(natReprTH u) $(natReprTH v)
          S.LeqProof <- return (S.leqTrans pf1 (S.leqRefl $(natReprTH w)))
          bv1Ext <- addExpr (AppExpr (M.UExt bv1Val $(natReprTH w)))
          bv2Ext <- addExpr (AppExpr (M.UExt bv2Val $(natReprTH w)))
          bv1Shifter <- addExpr (ValueExpr (M.BVValue $(natReprTH w) (natValue $(natReprTH v))))
          bv1Shf <- addExpr (AppExpr (M.BVShl $(natReprTH w) bv1Ext bv1Shifter))
          return $ AppExpr (M.BVOr $(natReprTH w) bv1Shf bv2Ext)
     |]
  S.BVSelect idx n bv -> do
    let w = S.bvWidth bv
    case natValue n + 1 <= natValue w of
      True ->
        [| do bvVal <- $(addEltTH interps bv)
              Just S.LeqProof <- return $ S.testLeq ($(natReprTH n) `addNat` (knownNat @1)) $(natReprTH w)
              pf1@S.LeqProof <- return $ S.leqAdd2 (S.leqRefl $(natReprTH idx)) (S.leqProof (knownNat @1) $(natReprTH n))
              pf2@S.LeqProof <- return $ S.leqAdd (S.leqRefl (knownNat @1)) $(natReprTH idx)
              Refl <- return $ S.plusComm (knownNat @1) $(natReprTH idx)
              pf3@S.LeqProof <- return $ S.leqTrans pf2 pf1
              S.LeqProof <- return $ S.leqTrans pf3 (S.leqProof ($(natReprTH idx) `addNat` $(natReprTH n)) $(natReprTH w))
              bvShf <- addExpr (AppExpr (M.BVShr $(natReprTH w) bvVal (M.mkLit $(natReprTH w) (natValue $(natReprTH idx)))))
              -- return $ ValueExpr (M.mkLit $(natReprTH n) 1)
              return $ AppExpr (M.Trunc bvShf $(natReprTH n))
         |]
      False -> [| do Just Refl <- return $ testEquality $(natReprTH n) $(natReprTH w)
                     return $ ValueExpr bvVal
                |]
  S.BVNeg w bv -> do
    -- Note: This is still untested
    [| do bvVal <- $(addEltTH interps bv)
          bvComp <- addExpr (AppExpr (M.BVComplement $(natReprTH w) bvVal))
          return $ AppExpr (M.BVAdd $(natReprTH w) bvComp (M.mkLit $(natReprTH w) 1))
     |]
  S.BVTestBit idx bv ->
    -- Note: below is untested, could be wrong.
    [| do bitExpVal <- addExpr (ValueExpr (M.BVValue $(natReprTH (S.bvWidth bv)) $(lift idx)))
          bval <- $(addEltTH interps bv)
          return (AppExpr (M.BVTestBit bitExpVal bval))
     |]
  S.BVAdd w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVAdd rep bval1 bval2))
     |]
  S.BVMul w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVMul rep bval1 bval2))
     |]
  S.BVShl w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVShl rep bval1 bval2))
     |]
  S.BVLshr w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVShr rep bval1 bval2))
     |]
  S.BVAshr w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVSar rep bval1 bval2))
     |]
  S.BVZext w bv ->
    [| do bval <- $(addEltTH interps bv)
          let rep = $(natReprTH w)
          return (AppExpr (M.UExt bval rep))
     |]
  S.BVSext w bv ->
    [| do bval <- $(addEltTH interps bv)
          let rep = $(natReprTH w)
          return (AppExpr (M.SExt bval rep))
     |]
  S.BVTrunc w bv ->
    [| do bval <- $(addEltTH interps bv)
          let rep = $(natReprTH w)
          return (AppExpr (M.Trunc bval rep))
     |]
  S.BVBitNot w bv ->
    [| do let rep = $(natReprTH w)
          bval <- $(addEltTH interps bv)
          return (AppExpr (M.BVComplement rep bval))
     |]
  S.BVBitAnd w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVAnd rep bval1 bval2))
     |]
  S.BVBitOr w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVOr rep bval1 bval2))
     |]
  S.BVBitXor w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVXor rep bval1 bval2))
     |]
  _ -> [| error "unsupported Crucible elt" |]



locToRegTH :: (1 <= APPC.ArchRegWidth ppc,
               M.RegAddrWidth (PPCReg ppc) ~ APPC.ArchRegWidth ppc)
           => proxy ppc
           -> APPC.Location ppc ctp
           -> Q Exp
locToRegTH _ (APPC.LocGPR (D.GPR gpr)) = [| PPC_GP (D.GPR $(lift gpr)) |]
locToRegTH _  APPC.LocIP       = [| PPC_IP |]
locToRegTH _  APPC.LocLNK      = [| PPC_LNK |]
locToRegTH _  APPC.LocCTR      = [| PPC_CTR |]
locToRegTH _  APPC.LocCR       = [| PPC_CR |]
locToRegTH _  APPC.LocXER      = [| PPC_XER |]
locToRegTH _  _                = [| undefined |]
-- fill the rest out later
